# encoding: utf-8

# Pretty-printers for Boost (http://www.boost.org)

# Copyright (C) 2009 RÃ¼diger Sonderfeld <ruediger@c-plusplus.de>

# Boost Software License - Version 1.0 - August 17th, 2003

# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:

# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

#
# Inspired _but not copied_ from libstdc++'s pretty printers
#

import gdb
import gdb.types
import gdb.printing
import re
import sys

# check "ptype/mtr" is supported
gdb.execute('ptype/mtr void', True, True)


class GDB_Value_Wrapper(gdb.Value):
    "Wrapper class for gdb.Value that allows setting custom attributes."
    pass


class Printer_Gen(object):

    class SubPrinter_Gen(object):
        def match_re(self, v):
            return self.re.search(str(v.basic_type)) != None

        def __init__(self, Printer):
            self.name = Printer.printer_name + '-' + Printer.version
            if hasattr(Printer, 'enabled'):
                self.enabled = Printer.enabled
            else:
                self.enabled = True
            if hasattr(Printer, 'supports'):
                self.re = None
                self.supports = Printer.supports
            else:
                self.re = re.compile(Printer.type_name_re)
                self.supports = self.match_re
            self.Printer = Printer

        def __call__(self, v):
            if not self.enabled:
                return None
            if self.supports(v):
                v.type_name = str(v.basic_type)
                return self.Printer(v)
            return None

    def __init__(self, name):
        self.name = name
        self.enabled = True
        self.subprinters = []

    def add(self, Printer):
        self.subprinters.append(Printer_Gen.SubPrinter_Gen(Printer))

    def __call__(self, value):
        v = GDB_Value_Wrapper(value)
        v.basic_type = gdb.types.get_basic_type(v.type)
        if not v.basic_type:
            return None
        if _is_boost_multi_index(v):
            if int(v.address) in Boost_Multi_Index.idx:
                v.idx = Boost_Multi_Index.idx[int(v.address)]
            else:
                v.idx = 0
        for subprinter_gen in self.subprinters:
            printer = subprinter_gen(v)
            if printer != None:
                return printer
        return None


class Type_Printer_Gen:
    "Type Printer Generator"

    def __init__(self, Type_Recognizer):
        self.name = Type_Recognizer.name
        self.enabled = Type_Recognizer.enabled
        self.Type_Recognizer = Type_Recognizer

    def instantiate(self):
        return self.Type_Recognizer()


printer_gen = Printer_Gen('boost')
type_printer_list = list()

# This function registers the top-level Printer generator with gdb.
# This should be called from .gdbinit.
def register_printer_gen(obj):
    "Register printer generator with objfile obj."
    gdb.printing.register_pretty_printer(obj, printer_gen)
    for tp in type_printer_list:
        gdb.types.register_type_printer(obj, tp)


# Register individual Printer with the top-level Printer generator.
def _register_printer(Printer):
    "Registers a Printer"
    printer_gen.add(Printer)
    return Printer

def _cant_register_printer(Printer):
    print('Printer [%s] not supported by this gdb version' % Printer.printer_name, file=sys.stderr)
    return Printer

def _conditionally_register_printer(condition):
    if condition:
        return _register_printer
    else:
        return _cant_register_printer

def _register_type_recognizer(Type_Recognizer):
    type_printer_list.append(Type_Printer_Gen(Type_Recognizer))
    return Type_Recognizer


###
### Individual Printers follow.
###
### Relevant fields:
###
### - 'printer_name' : Subprinter name used by gdb. (Required.) If it contains
###     regex operators, they must be escaped when refering to it from gdb.
### - 'version' : Appended to the subprinter name. (Required.)
### - 'supports(GDB_Value_Wrapper)' classmethod : If it exists, it is used to
###     determine if the Printer supports the given object.
### - 'type_name_re' : If 'supports(basic_type)' doesn't exist, a default
###     version is used which simply tests whether the type name matches this
###     re. (Either supports() or type_name_re is required.)
### - 'enabled' : If this exists and is set to false, disable printer.
### - '__init__' : Its only argument is a GDB_Value_Wrapper.
###

@_register_printer
class BoostIteratorRange:
    "Pretty Printer for boost::iterator_range (Boost.Range)"
    printer_name = 'boost::iterator_range'
    version = '1.40'
    type_name_re = '^boost::iterator_range<.*>$'

    class _iterator:
        def __init__(self, begin, end):
            self.item = begin
            self.end = end
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            if self.item == self.end:
                raise StopIteration
            count = self.count
            self.count = self.count + 1
            elem = self.item.dereference()
            self.item = self.item + 1
            return ('[%d]' % count, elem)

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def children(self):
        return self._iterator(self.value['m_Begin'], self.value['m_End'])

    def to_string(self):
        begin = self.value['m_Begin']
        end = self.value['m_End']
        return '%s of length %d' % (self.typename, int(end - begin))

    def display_hint(self):
        return 'array'

@_register_printer
class BoostOptional:
    "Pretty Printer for boost::optional (Boost.Optional)"
    printer_name = 'boost::optional'
    version = '1.40'
    type_name_re = '^boost::optional<(.*)>$'
    regex = re.compile(type_name_re)

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    class _iterator:
        def __init__(self, member, empty):
            self.member = member
            self.done = empty

        def __iter__(self):
            return self

        def __next__(self):
            if(self.done):
                raise StopIteration
            self.done = True
            return ('value', self.member.dereference())

    def children(self):
        initialized = self.value['m_initialized']
        if(not initialized):
            return self._iterator('', True)
        else:
            match = BoostOptional.regex.search(self.typename)
            if match:
                try:
                    membertype = gdb.lookup_type(match.group(1)).pointer()
                    member = self.value['m_storage']['dummy_']['data'].address.cast(membertype)
                    return self._iterator(member, False)
                except:
                    return self._iterator('', True)

    def to_string(self):
        initialized = self.value['m_initialized']
        if(not initialized):
            return "%s is not initialized" % self.typename
        else:
            return "%s is initialized" % self.typename

@_register_printer
class BoostReferenceWrapper:
    "Pretty Printer for boost::reference_wrapper (Boost.Ref)"
    printer_name = 'boost::reference_wrapper'
    version = '1.40'
    type_name_re = '^boost::reference_wrapper<(.*)>$'

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def to_string(self):
        return '(%s) %s' % (self.typename, self.value['t_'].dereference())

@_register_printer
class BoostTribool:
    "Pretty Printer for boost::logic::tribool (Boost.Tribool)"
    printer_name = 'boost::logic::tribool'
    version = '1.40'
    type_name_re = '^boost::logic::tribool$'

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def to_string(self):
        state = self.value['value']
        s = 'indeterminate'
        if(state == 0):
            s = 'false'
        elif(state == 1):
            s = 'true'
        return '(%s) %s' % (self.typename, s)

@_register_printer
class BoostScopedPtr:
    "Pretty Printer for boost::scoped/intrusive_ptr/array (Boost.SmartPtr)"
    printer_name = 'boost::scoped/intrusive_ptr/array'
    version = '1.40'
    type_name_re = '^boost::(intrusive|scoped)_(ptr|array)<(.*)>$'

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def to_string(self):
        return '(%s) %s' % (self.typename, self.value['px'])

@_register_printer
class BoostSharedPtr:
    "Pretty Printer for boost::shared/weak_ptr/array (Boost.SmartPtr)"
    printer_name = 'boost::shared/weak_ptr/array'
    version = '1.40'
    type_name_re = '^boost::(weak|shared)_(ptr|array)<(.*)>$'

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def to_string(self):
        if self.value['px'] == 0x0:
            return '(%s) %s' % (self.typename, self.value['px'])
        countobj = self.value['pn']['pi_'].dereference()
        refcount = countobj['use_count_']
        weakcount = countobj['weak_count_']
        return '(%s) (count %d, weak count %d) %s' % (self.typename,
                                                      refcount, weakcount,
                                                      self.value['px'])

@_register_printer
class BoostCircular:
    "Pretty Printer for boost::circular_buffer (Boost.Circular)"
    printer_name = 'boost::circular_buffer'
    version = '1.40'
    type_name_re = '^boost::circular_buffer<(.*)>$'

    class _iterator:
        def __init__(self, first, last, buff, end, size):
            self.item = first # virtual beginning of the circular buffer
            self.last = last  # virtual end of the circular buffer (one behind the last element).
            self.buff = buff  # internal buffer used for storing elements in the circular buffer
            self.end = end    # internal buffer's end (end of the storage space).
            self.size = size
            self.capa = int(end-buff)
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            if self.count == self.size:
                raise StopIteration
            count = self.count
            crt=self.buff + (count + self.item - self.buff) % self.capa
            elem = crt.dereference()
            self.count = self.count + 1
            return ('[%d]' % count, elem)




            if self.item == self.last:
                raise StopIteration
            count = self.count
            self.count = self.count + 1
            elem = self.item.dereference()
            self.item = self.item + 1
            if self.item == self.end:
                self.item == self.buff
            return ('[%d]' % count, elem)

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def children(self):
        return self._iterator(self.value['m_first'], self.value['m_last'], self.value['m_buff'], self.value['m_end'], self.value['m_size'])

    def to_string(self):
        first = self.value['m_first']
        last = self.value['m_last']
        buff = self.value['m_buff']
        end = self.value['m_end']
        size = self.value['m_size']
        return '%s of length %d/%d' % (self.typename, int(size), int(end-buff))

    def display_hint(self):
        return 'array'

@_register_printer
class BoostArray:
    "Pretty Printer for boost::array (Boost.Array)"
    printer_name = 'boost::array'
    version = '1.40'
    type_name_re = '^boost::array<(.*)>$'

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def to_string(self):
        return str(self.value['elems'])

    def display_hint(self):
        return 'array'

@_register_printer
class BoostVariant:
    "Pretty Printer for boost::variant (Boost.Variant)"
    printer_name = 'boost::variant'
    version = '1.40'
    type_name_re = '^boost::variant<(.*)>$'
    regex = re.compile(type_name_re)

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def to_string(self):
        m = BoostVariant.regex.search(self.typename)
        # TODO this breaks with boost::variant< foo<a,b>, bar >!
        types = [s.strip() for s in m.group(1).split(',')]
        which = int(self.value['which_'])
        type = types[which]
        data = ''
        try:
            ptrtype = gdb.lookup_type(type).pointer()
            data = self.value['storage_']['data_']['buf'].address.cast(ptrtype)
        except:
            data = self.value['storage_']['data_']['buf']
        return '(boost::variant<...>) which (%d) = %s value = %s' % (which,
                                                                     type,
                                                                     data.dereference())

@_register_printer
class BoostUuid:
    "Pretty Printer for boost::uuids::uuid (Boost.Uuid)"
    printer_name = 'boost::uuids::uuid'
    version = '1.40'
    type_name_re = '^boost::uuids::uuid$'

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def to_string(self):
        u = (self.value['data'][i] for i in range(16))
        s = 'xxxx-xx-xx-xx-xxxxxx'.replace('x', '%02x') % tuple(u)
        return '(%s) %s' % (self.typename, s)

##################################################
# boost::intrusive::set                          #
##################################################

def get_named_template_argument(gdb_type, arg_name):
    n = 0;
    while True:
        try:
            arg = gdb_type.strip_typedefs().template_argument(n)
            if (str(arg).startswith(arg_name)):
                return arg
            n += 1
        except RuntimeError:
            return None

def intrusive_container_has_size_member(intrusive_container_type):
    constant_size_arg = get_named_template_argument(intrusive_container_type, "boost::intrusive::constant_time_size")
    if not constant_size_arg:
        return True
    if str(constant_size_arg.template_argument(0)) == 'false':
        return False
    return True

def intrusive_iterator_to_string(iterator_value):
    opttype = iterator_value.type.template_argument(0).template_argument(0)

    base_hook_traits = get_named_template_argument(opttype, "boost::intrusive::detail::base_hook_traits")
    if base_hook_traits:
        value_type = base_hook_traits.template_argument(0)
        return iterator_value["members_"]["nodeptr_"].cast(value_type.pointer()).dereference()

    member_hook_traits = get_named_template_argument(opttype, "boost::intrusive::detail::member_hook_traits")
    if member_hook_traits:
        value_type = member_hook_traits.template_argument(0)
        member_offset = member_hook_traits.template_argument(2).cast(gdb.lookup_type("size_t"))
        currentElementAddress = iterator_value["members_"]["nodeptr_"].cast(gdb.lookup_type("size_t")) - member_offset
        return currentElementAddress.cast(value_type.pointer()).dereference()

    return iterator_value["members_"]["nodeptr_"]


class BoostIntrusiveRbtreeIterator:
    def __init__(self, rbTreeHeader, elementPointerType, memberOffset=0):
        self.header = rbTreeHeader
        self.memberOffset = memberOffset
        if memberOffset == 0:
            self.nodeType = elementPointerType
        else:
            self.nodeType = gdb.lookup_type("boost::intrusive::rbtree_node<void*>").pointer();
            self.elementPointerType = elementPointerType
        self.node = rbTreeHeader['left_'].cast(self.nodeType)

    def __iter__(self):
        return self

    def getElementPointerFromNodePointer(self):
        if self.memberOffset == 0:
            return self.node
        else:
            currentElementAddress = self.node.cast(gdb.lookup_type("size_t")) - self.memberOffset
            return currentElementAddress.cast(self.elementPointerType)

    def __next__(self):
        # empty set or reached rightmost leaf
        if not self.node:
            raise StopIteration
        result = self.getElementPointerFromNodePointer()
        if self.node != self.header["right_"].cast(self.nodeType):
            # Compute the next node.
            node = self.node
            if node.dereference()['right_']:
                node = node.dereference()['right_']
                while node.dereference()['left_']:
                    node = node.dereference()['left_']
            else:
                parent = node.dereference()['parent_']
                while node == parent.dereference()['right_']:
                    node = parent
                    parent = parent.dereference()['parent_']
                if node.dereference()['right_'] != parent:
                    node = parent
            self.node = node.cast(self.nodeType)
        else:
            self.node = 0
        return result

@_register_printer
class BoostIntrusiveSet:
    "Pretty Printer for boost::intrusive::set (Boost.Intrusive)"
    printer_name = 'boost::intrusive::set'
    version = '1.40'
    type_name_re = '^boost::intrusive::set<.*>$'
    enabled = False

    class _iter:
        def __init__(self, rbiter):
            self.rbiter = rbiter
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            item = self.rbiter.next().dereference()
            result = ('[%d]' % self.count, item)
            self.count = self.count + 1
            return result

    def __init__(self, value):
        self.typename = value.type_name
        self.val = value
        self.elementType = self.val.type.strip_typedefs().template_argument(0)

    def getHeader(self):
        return self.val["tree_"]["data_"]["node_plus_pred_"]["header_plus_size_"]["header_"]

    def getSize(self):
        return self.val["tree_"]["data_"]["node_plus_pred_"]["header_plus_size_"]["size_"]

    def hasElements(self):
        header = self.getHeader()
        firstElement = header["parent_"]
        if firstElement:
            return True
        else:
            return False

    def to_string (self):
        if (intrusive_container_has_size_member(self.val.type)):
            return "boost::intrusive::set<%s> with %d elements" % (self.elementType, self.getSize())
        elif (self.hasElements()):
            return "non-empty boost::intrusive::set<%s>" % self.elementType
        else:
            return "empty boost::intrusive::set<%s>" % self.elementType

    def children (self):
        elementPointerType = self.elementType.pointer()
        member_hook = get_named_template_argument(self.val.type, "boost::intrusive::member_hook")
        if member_hook:
            memberOffset = member_hook.template_argument(2).cast(gdb.lookup_type("size_t"))
            return self._iter (BoostIntrusiveRbtreeIterator(self.getHeader(), elementPointerType, memberOffset))
        else:
            return self._iter (BoostIntrusiveRbtreeIterator(self.getHeader(), elementPointerType))


@_register_printer
class BoostIntrusiveTreeIterator:
    "Pretty Printer for boost::intrusive::set<*>::iterator (Boost.Intrusive)"
    printer_name = 'boost::intrusive::tree_iterator'
    version = '1.40'
    type_name_re = '^boost::intrusive::tree_iterator<.*>$'
    enabled = False

    def __init__(self, value):
        self.val = value
        self.typename = value.type_name

    def to_string(self):
        return intrusive_iterator_to_string(self.val)


##################################################
# boost::intrusive::list                         #
##################################################

class BoostIntrusiveListIterator:
    def __init__(self, listHeader, elementPointerType, memberOffset=0):
        self.header = listHeader
        self.memberOffset = memberOffset
        if memberOffset == 0:
            self.nodeType = elementPointerType
        else:
            self.nodeType = gdb.lookup_type("boost::intrusive::list_node<void*>").pointer();
            self.elementPointerType = elementPointerType
        nextNode = listHeader['next_']
        if nextNode != listHeader.address:
            self.node = nextNode.cast(self.nodeType)
        else:
            self.node = 0

    def __iter__(self):
        return self

    def getElementPointerFromNodePointer(self):
        if self.memberOffset == 0:
            return self.node
        else:
            currentElementAddress = self.node.cast(gdb.lookup_type("size_t")) - self.memberOffset
            return currentElementAddress.cast(self.elementPointerType)

    def __next__(self):
        # empty list or reached end
        if not self.node:
            raise StopIteration
        result = self.getElementPointerFromNodePointer()
        nextNode = self.node['next_']
        if nextNode != self.header.address:
            self.node = nextNode.cast(self.nodeType)
        else:
            self.node = 0
        return result

@_register_printer
class BoostIntrusiveList:
    "Pretty Printer for boost::intrusive::list (Boost.Intrusive)"
    printer_name = 'boost::intrusive::list'
    version = '1.40'
    type_name_re = '^boost::intrusive::list<.*>$'
    enabled = False

    class _iter:
        def __init__(self, listiter):
            self.listiter = listiter
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            item = self.listiter.next().dereference()
            result = ('[%d]' % self.count, item)
            self.count = self.count + 1
            return result

    def __init__(self, value):
        self.typename = value.type_name
        self.val = value
        self.elementType = self.val.type.strip_typedefs().template_argument(0)

    def getHeader(self):
        return self.val["data_"]["root_plus_size_"]["root_"]

    def getSize(self):
        return self.val["data_"]["root_plus_size_"]["size_"]

    def hasElements(self):
        header = self.getHeader()
        firstElement = header["next_"]
        rootElement = header.address
        if firstElement != rootElement:
            return True
        else:
            return False

    def to_string (self):
        if (intrusive_container_has_size_member(self.val.type)):
            return "boost::intrusive::list<%s> with %d elements" % (self.elementType, self.getSize())
        elif (self.hasElements()):
            return "non-empty boost::intrusive::list<%s>" % self.elementType
        else:
            return "empty boost::intrusive::list<%s>" % self.elementType

    def children (self):
        elementPointerType = self.elementType.pointer()
        member_hook = get_named_template_argument(self.val.type, "boost::intrusive::member_hook")
        if member_hook:
            memberOffset = member_hook.template_argument(2).cast(gdb.lookup_type("size_t"))
            return self._iter (BoostIntrusiveListIterator(self.getHeader(), elementPointerType, memberOffset))
        else:
            return self._iter (BoostIntrusiveListIterator(self.getHeader(), elementPointerType))

@_register_printer
class BoostIntrusiveListIterator:
    "Pretty Printer for boost::intrusive::list<*>::iterator (Boost.Intrusive)"
    printer_name = 'boost::intrusive::list_iterator'
    version = '1.40'
    type_name_re = '^boost::intrusive::list_iterator<.*>$'
    enabled = False

    def __init__(self, value):
        self.val = value

    def to_string(self):
        return intrusive_iterator_to_string(self.val)

#
# Intrusive containers 1.55
#

class _aux_save_value_as_variable(gdb.Function):
    def __init__(self, v):
        super(_aux_save_value_as_variable, self).__init__('_aux_save_value_as_variable')
        self.value = v
    def invoke(self):
        return self.value

def save_value_as_variable(v, s):
    """Save gdb.Value v as gdb variable s."""
    assert isinstance(v, gdb.Value), 'arg 1 not a gdb.Value'
    assert isinstance(s, str), 'arg 2 not a string'
    _aux_save_value_as_variable(v)
    gdb.execute('set var ' + s + ' = $_aux_save_value_as_variable()')

def shorten_ns(tag):
    if tag.startswith('boost::intrusive::'):
        return 'bi::' + tag[18:]
    else:
        return tag

def apply_method(v, f):
    """Apply method to given value."""
    assert isinstance(v, gdb.Value), 'arg 1 not a gdb.Value'
    assert isinstance(f, str), 'arg 2 not a string'
    if v.address:
        # use hack by taking address; this might work even when f() involves references
        return gdb.parse_and_eval('((' + str(v.type.strip_typedefs()) + ' *)' + str(int(v.address)) + ')->' + f + '()')
    else:
        # use inferior value
        save_value_as_variable(v, '$_v')
        return gdb.parse_and_eval('$_v.' + f + '()')

@_register_type_recognizer
class IGeneric_Hook_Type_Recognizer:
    "Type Recognizer for boost::intrusive::generic_hook"
    name = 'boost::intrusive::generic_hook (1.55.0)'
    enabled = True
    target_re = re.compile('^boost::intrusive::generic_hook<.*>$')

    def recognize(self, t):
        if not t.tag or self.target_re.search(t.tag) == None:
            return None
        # hook_tag: default (base) or member
        hook_tag = t.template_argument(1).strip_typedefs().tag
        # link mode
        link_mode = str(t.template_argument(2)).split('::')[2]
        # node_type: first subclass, or the first subclass of the first subclass
        node_t = t.fields()[0].type
        if node_t.strip_typedefs().tag.startswith('boost::intrusive::node_holder'):
            node_t = node_t.fields()[0].type
        node_tag = node_t.strip_typedefs().tag
        return 'bi::generic_hook< '+ shorten_ns(node_tag) + ', ' + shorten_ns(hook_tag) + ', ' + link_mode + ' >'

@_register_printer
class IGeneric_Hook_Printer:
    "Pretty Printer for boost::intrusive::generic_hook"
    printer_name = 'boost::intrusive::generic_hook'
    version = '1.55'
    type_name_re = '^boost::intrusive::generic_hook<.*>$'
    enabled = True

    def __init__(self, value):
        self.value = value

    def to_string(self):
        # the actual node is either the first subclass, or the first subclass of the first subclass
        node = self.value.cast(self.value.type.fields()[0].type)
        if node.type.strip_typedefs().tag.startswith('boost::intrusive::node_holder'):
            node = node.cast(node.type.fields()[0].type)
        return str(node)

@_register_type_recognizer
class IHook_Type_Recognizer:
    "Type Recognizer for boost::intrusive::*_(base|member)_hook"
    name = 'boost::intrusive::*_(base|member)_hook (1.55.0)'
    enabled = True
    target_re = re.compile('^boost::intrusive::(avl_set|bs_set|list|set|slist|splay_set|unordered_set)_(base|member)_hook<.*>$')

    def recognize(self, t):
        if not t.tag or not self.target_re.search(t.tag):
            return None
        # just print the underlying generic hook
        generic_hook_t = t.fields()[0].type
        return IGeneric_Hook_Type_Recognizer().recognize(generic_hook_t)

@_register_printer
class IHook_Printer:
    "Pretty Printer for boost::intrusive::*_(base|member)_hook"
    printer_name = 'boost::intrusive::*_(base|member)_hook'
    version = '1.55'
    type_name_re = '^boost::intrusive::(avl_set|bs_set|list|set|slist|splay_set|unordered_set)_(base|member)_hook<.*>$'
    enabled = True

    def __init__(self, value):
        self.val = value

    def to_string(self):
        # cast to and print underlying generic hook
        generic_hook_t = self.val.type.fields()[0].type
        generic_hook = self.val.cast(generic_hook_t)
        return str(generic_hook)

class _ilist_get_root_node(gdb.Function):
    """Get node_ptr pointing to the root of an intrusive list. Argument must be a program variable."""
    def __init__(self):
        super(_ilist_get_root_node, self).__init__('_ilist_get_root_node')
    def invoke(self, l_str_gdb):
        # check we are passed a string
        if not str(l_str_gdb.type).startswith('char ['):
            print('_ilist_get_root_node: arg must be a gdb variable name; type given: ' + str(l_str_gdb.type), file=sys.stderr)
            return None
        # remove enclosing double quotes
        l_str = str(l_str_gdb)[1:-1]
        # load variable as gdb.Value
        l = gdb.selected_frame().read_var(l_str)
        # check it's a bi::list
        if not str(l.type.strip_typedefs()).startswith('boost::intrusive::list<'):
            print('_ilist_get_root_node: arg must be a bi::list; given: ' + str(l.type.strip_typedefs()), file=sys.stderr)
            return None
        # fetch node_ptr type
        node_ptr_t = gdb.lookup_type(str(l.type.fields()[0].type.strip_typedefs()) + '::node_ptr')
        return gdb.parse_and_eval('boost::intrusive::pointer_traits<' + str(node_ptr_t.strip_typedefs()) + '>::pointer_to(' + l_str + '.data_.root_plus_size_.root_)')
#_ilist_get_root_node()

_bi_value_traits = dict()
def _bi_get_value_traits(cont_t):
    """Get value_traits type from container type."""
    assert isinstance(cont_t, gdb.Type), 'arg not a gdb.Type'
    # use value saved in table, if available
    if str(cont_t.strip_typedefs()) in _bi_value_traits:
        t = gdb.lookup_type(_bi_value_traits[str(cont_t.strip_typedefs())])
    else:
        try:
            t = gdb.lookup_type(str(cont_t.strip_typedefs()) + '::value_traits')
        except gdb.error:
            # also try first template argument of first subclass
            try:
                t = cont_t.strip_typedefs().fields()[0].type.template_argument(0)
            except:
                print('_bi_get_value_traits: value_traits typedef missing from container type\n' +
                      '_bi_get_value_traits: to work around this, add it manually with, e.g.:\n' +
                      '_bi_get_value_traits: \'py import boost.printers\'\n' +
                      '_bi_get_value_traits: \'py boost.printers._bi_value_traits["'
                      + str(cont_t.strip_typedefs()) + '"]="<value_traits_type>"\'',
                      file=sys.stderr)
                raise gdb.error
    return t

_bi_node_traits = dict()
def _bi_get_node_traits(value_traits_t):
    """Get node_traits type from value_traits type."""
    assert isinstance(value_traits_t, gdb.Type), 'arg not a gdb.Type'
    # use value saved in table, if available
    if str(value_traits_t.strip_typedefs()) in _bi_node_traits:
        t = gdb.lookup_type(_bi_node_traits[str(value_traits_t.strip_typedefs())])
    else:
        try:
            t = gdb.lookup_type(str(value_traits_t.strip_typedefs()) + '::node_traits')
        except gdb.error:
            # missing typedef...
            if (str(value_traits_t.strip_typedefs()).startswith('boost::intrusive::bhtraits<')
                or str(value_traits_t.strip_typedefs()).startswith('boost::intrusive::mhtraits<')):
                # for builtin (b|m)htraits, node_traits is second template parameter
                t = value_traits_t.template_argument(1)
            elif str(value_traits_t.strip_typedefs()).startswith('boost::intrusive::trivial_value_traits<'):
                # for builtin trivial_value_traits, node_traits is first template parameter
                t = value_traits_t.template_argument(0)
            else:
                print('_bi_get_node_traits: node_traits typedef missing from value_traits type\n' +
                      '_bi_get_node_traits: to work around this, add it manually with, e.g.:\n' +
                      '_bi_get_node_traits: \'py import boost.printers\'\n' +
                      '_bi_get_node_traits: \'py boost.printers._bi_node_traits["'
                      + str(value_traits_t.strip_typedefs()) + '"]="<node_traits_type>"\'',
                      file=sys.stderr)
                raise gdb.error
    return t

_bi_to_value_ptr = dict()
def _bi_apply_to_value_ptr(value_traits_t, node_ptr):
    """Get value_ptr from node_ptr. value_traits_t is a gdb.Type, node_ptr is a gdb.Value."""
    assert isinstance(value_traits_t, gdb.Type), 'arg 1 not a gdb.Type'
    assert isinstance(node_ptr, gdb.Value), 'arg 2 not a gdb.Value'
    # use convenience method saved in table, if available
    if str(value_traits_t.strip_typedefs()) in _bi_to_value_ptr:
        val_ptr = _bi_to_value_ptr[str(value_traits_t.strip_typedefs())](node_ptr)
    elif str(value_traits_t.strip_typedefs()).startswith('boost::intrusive::trivial_value_traits<'):
        val_ptr = node_ptr
    elif str(value_traits_t.strip_typedefs()).startswith('boost::intrusive::bhtraits<'):
        # internal base hook traits
        # this will fail (give wrong answer?) if the val struct has multiple bases of type list_node
        val_ptr_t = gdb.lookup_type(str(value_traits_t.strip_typedefs()) + '::pointer')
        val_ptr = node_ptr.cast(val_ptr_t)
    elif str(value_traits_t.strip_typedefs()).startswith('boost::intrusive::mhtraits<'):
        # internal member hook traits
        # offset is 3rd template argument
        offset = value_traits_t.template_argument(2)
        assert isinstance(offset, gdb.Value), '3rd template argument of mhtraits should be a member pointer'
        offset_int = int(offset)
        node_ptr_int = int(node_ptr)
        val_ptr_t = gdb.lookup_type(str(value_traits_t.strip_typedefs()) + '::pointer')
        val_ptr = gdb.parse_and_eval(str(val_ptr_t) + '(' + str(node_ptr_int - offset_int) + ')')
    else:
        # try to call value_traits_t::to_value_ptr()
        save_value_as_variable(node_ptr, '$_node_ptr')
        try:
            val_ptr = gdb.parse_and_eval(str(value_traits_t) + '::to_value_ptr($_node_ptr)')
        except:
            print('_bi_apply_to_value_ptr: could not apply ' + str(value_traits_t.strip_typedefs()) + '::to_value_ptr()\n' +
                  '_bi_apply_to_value_ptr: most likely, existing version involves references, and call involves inferior values\n' +
                  '_bi_apply_to_value_ptr: to work around this, write a new python function, then register it with:\n' +
                  '_bi_apply_to_value_ptr: \'py import boost.printers\'\n' +
                  '_bi_apply_to_value_ptr: \'py boost.printers._bi_to_value_ptr["' + str(value_traits_t.strip_typedefs()) + '"]=<python_function>',
                  file=sys.stderr)
            raise gdb.error
    return val_ptr

_bi_get_next = dict()
def _bi_apply_get_next(node_traits_t, node_ptr):
    """Apply node_traits::get_next(). node_traits_t is a gdb.Type, node_ptr is a gdb.Value."""
    assert isinstance(node_traits_t, gdb.Type), 'arg 1 not a gdb.Type'
    assert isinstance(node_ptr, gdb.Value), 'arg 2 not a gdb.Value'
    # use convenience method saved in table, if available
    if str(node_traits_t.strip_typedefs()) in _bi_get_next:
        next_node_ptr = _bi_get_next[str(node_traits_t.strip_typedefs())](node_ptr)
    elif (str(node_traits_t.strip_typedefs()).startswith('boost::intrusive::list_node_traits<')
          or str(node_traits_t.strip_typedefs()).startswith('boost::intrusive::slist_node_traits<')):
        next_node_ptr = node_ptr['next_']
    else:
        # try to call node_traits_t::get_next()
        save_value_as_variable(node_ptr, '$_node_ptr')
        try:
            next_node_ptr = gdb.parse_and_eval(str(node_traits_t) + '::get_next($_node_ptr)')
        except:
            print('_bi_apply_get_next: could not apply ' + str(node_traits_t.strip_typedefs()) + '::get_next()\n' +
                  '_bi_apply_get_next: most likely, existing version involves references, and call involves inferior values\n' +
                  '_bi_apply_get_next: to work around this, write a new python function, then register it with:\n' +
                  '_bi_apply_get_next: \'py import boost.printers\'\n' +
                  '_bi_apply_get_next: \'py boost.printers._bi_get_next["' + str(node_traits_t.strip_typedefs()) + '"]=<python_function>',
                  file=sys.stderr)
            raise gdb.error
    return next_node_ptr

def value_from_iiterator(it):
    value_traits_t = it.type.template_argument(0)
    node_ptr = it['members_']['nodeptr_']
    value_ptr = _bi_apply_to_value_ptr(value_traits_t, node_ptr)
    return value_ptr.referenced_value()

@_register_printer
class IIterator_Printer:
    "Pretty Printer for boost::intrusive::(list|slist|tree)_iterator"
    printer_name = 'boost::intrusive::(list|slist|tree)_iterator'
    version = '1.55'
    type_name_re = '^boost::intrusive::(list|slist|tree)_iterator<.*>$'
    enabled = True

    def __init__(self, value):
        self.val = value

    def to_string(self):
        try:
            value_str = str(value_from_iiterator(self.val))
        except:
            value_str = 'N/A'
        return str(self.val['members_']['nodeptr_']) + ' -> ' + value_str

@_register_printer
class IList_Printer:
    "Pretty Printer for boost::intrusive::list"
    printer_name = 'boost::intrusive::list'
    version = '1.55'
    type_name_re = '^boost::intrusive::list<.*>$'
    enabled = True

    class Iterator:
        def __init__(self, l):
            self.value_traits_t = _bi_get_value_traits(l.type)
            self.node_traits_t = _bi_get_node_traits(self.value_traits_t)
            self.root_node_ptr = apply_method(l, 'get_root_node')

        def __iter__(self):
            self.count = 0
            self.crt_node_ptr = _bi_apply_get_next(self.node_traits_t, self.root_node_ptr)
            return self

        def __next__(self):
            if self.crt_node_ptr == self.root_node_ptr:
                raise StopIteration
            val_ptr = _bi_apply_to_value_ptr(self.value_traits_t, self.crt_node_ptr)
            try:
                val_str = str(val_ptr.referenced_value())
            except:
                val_str = 'N/A'
            result = ('[%d, %s]' % (self.count, hex(int(val_ptr))), val_str)
            self.count = self.count + 1
            self.crt_node_ptr = _bi_apply_get_next(self.node_traits_t, self.crt_node_ptr)
            return result

    def __init__(self, l):
        self.l = l
        self.value_type = self.l.type.template_argument(0)

    def empty(self):
        it_begin = apply_method(self.l, 'begin')
        it_end = apply_method(self.l, 'end')
        return it_begin['members_']['nodeptr_'] == it_end['members_']['nodeptr_']

    def to_string (self):
        return "bi::list<%s>" % self.value_type.strip_typedefs()

        if False and (intrusive_container_has_size_member(self.l.type)):
            return "bi::list<%s> with %d elements" % (self.value_type, self.getSize())
        elif not self.empty():
            return "non-empty bi::list<%s>" % self.value_type
        else:
            return "empty bi::list<%s>" % self.value_type.strip_typedefs()

    def children (self):
        return self.Iterator(self.l)


@_register_printer
class BoostGregorianDate:
    "Pretty Printer for boost::gregorian::date"
    printer_name = 'boost::gregorian::date'
    version = '1.40'
    type_name_re = '^boost::gregorian::date$'

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def to_string(self):
        n = int(self.value['days_'])
        # Check for uninitialized case
        if n==2**32-2:
            return '(%s) uninitialized' % self.typename
        # Convert date number to year-month-day
        a = n + 32044
        b = (4*a + 3) / 146097
        c = a - (146097*b)/4
        d = (4*c + 3)/1461
        e = c - (1461*d)/4
        m = (5*e + 2)/153
        day = e + 1 - (153*m + 2)/5
        month = m + 3 - 12*(m/10)
        year = 100*b + d - 4800 + (m/10)
        return '(%s) %4d-%02d-%02d' % (self.typename, year,month,day)

@_register_printer
class BoostPosixTimePTime:
    "Pretty Printer for boost::posix_time::ptime"
    printer_name = 'boost::posix_time::ptime'
    version = '1.40'
    type_name_re = '^boost::posix_time::ptime$'

    def __init__(self, value):
        self.typename = value.type_name
        self.value = value

    def to_string(self):
        n = int(self.value['time_']['time_count_']['value_'])
        # Check for uninitialized case
        if n==2**63-2:
            return '(%s) uninitialized' % self.typename
        # Represent time in a raw fashion
        return '(%s) %d' % (self.typename, n)

#
# Some utility methods.
#

def _paren_split(s, target_paren = '<'):
    "Split the given string at commas (,) at the first paranthesis sublevel of target_paren, ignoring commas within other paranthesized blocks. This can be used to extract template arguments."
    open_parens = '([{<'
    close_parens = ')]}>'
    end_paren = {}
    end_paren['('] = ')'
    end_paren['['] = ']'
    end_paren['{'] = '}'
    end_paren['<'] = '>'
    if target_paren not in open_parens:
        print('error: _paren_split: target_paren [' + target_paren + '] must be one of [' + open_parens + ']', file=sys.stderr)
        return None
    paren_stack = []
    res = []
    st = 0
    for i in range(len(s)):
        if s[i] in open_parens:
            if len(paren_stack) == 0 and s[i] == target_paren:
                st = i + 1
            paren_stack.append(s[i])
        elif s[i] in close_parens:
            if len(paren_stack) == 0 or s[i] != end_paren[paren_stack[-1]]:
                # mismatched parens
                return None
            if len(paren_stack) == 1 and paren_stack[0] == target_paren:
                res += [[st, i]]
                st = i + 1
            del paren_stack[-1]
        elif s[i] == ',':
            if len(paren_stack) == 0:
                # comma among primary identifiers
                return None
            if len(paren_stack) == 1 and paren_stack[0] == target_paren:
                res += [[st, i]]
                st = i + 1
    return res

def _strip_inheritance_qual(s):
    if s.startswith('public '):
        return s[7:]
    if s.startswith('private '):
        return s[8:]
    if s.startswith('protected '):
        return s[10:]
    return s

def _get_subtype(basic_type, idx):
    "Return the subtype of a given type. idx can be an integer indicating the index of the subtype to be returned, or a list of such indexes, in which case a list of types is returned."
    s = gdb.execute('ptype/mtr ' + str(basic_type), True, True)
    if not s.startswith('type = '):
        print('error: _get_subtype(' + str(basic_type) + '): s = ' + s, file=sys.stderr)
        return None
    s = s[7:]
    s = s.split('\n')[0]
    if not s[-1] == '{':
        print('error: _get_subtype(' + str(basic_type) + '): not a class?', file=sys.stderr)
        return None
    s = s[:-1]
    if len(s.split(' : ')) != 2:
        print('error: _get_subtype(' + str(basic_type) + '): no subtypes?', file=sys.stderr)
        return None
    s = 'void< ' + s.split(' : ')[1] + ' >'
    r = _paren_split(s)
    if len(r) == 0:
        print('error: _get_subtype(' + str(basic_type) + '): s = ' + s + '; r = ' + str(r), file=sys.stderr)
        return None
    if type(idx) == list:
        idx_list = idx
    else:
        idx_list = [idx]
    res = []
    for i in idx_list:
        if i >= len(r):
            res.append(None)
        else:
            t_s = _strip_inheritance_qual(s[r[i][0]:r[i][1]].strip())
            t = gdb.lookup_type(t_s)
            res.append(t)
    if type(idx) == list:
        return res
    else:
        return res[0]

def _is_boost_multi_index(v):
    return str(v.basic_type).startswith('boost::multi_index::multi_index_container')

def _boost_multi_index_get_indexes(v):
    "Save the index types of a multi_index_container in v.indexes."
    v.main_args = _paren_split(str(v.basic_type))
    if len(v.main_args) != 3:
        print('error parsing: ' + str(v.basic_type), file=sys.stderr)
        return False
    arg2_str = str(v.basic_type)[v.main_args[1][0]:v.main_args[1][1]] # the 2nd template arg
    arg2_args = _paren_split(arg2_str)
    if len(arg2_args) == 0:
        print('error parsing arg2 of: ' + str(v.basic_type), file=sys.stderr)
        return False
    v.indexes = []
    for r in arg2_args:
        v.indexes.append(arg2_str[r[0]:r[1]].split('<')[0].strip())

# The size in pointers of the index fields for all index types.
_boost_multi_index_index_size = {}
_boost_multi_index_index_size['boost::multi_index::ordered_unique'] = 3
_boost_multi_index_index_size['boost::multi_index::ordered_non_unique'] = 3
_boost_multi_index_index_size['boost::multi_index::hashed_unique'] = 1
_boost_multi_index_index_size['boost::multi_index::hashed_non_unique'] = 1
_boost_multi_index_index_size['boost::multi_index::sequenced'] = 2
_boost_multi_index_index_size['boost::multi_index::random_access'] = 1

#
# The following is an experimental printer for boost::multi_index_container
# using ordered unique/nonunique or sequenced index. This might not always
# work for various reasons.
#
# 1. I did not fully decode the templated construction of these containers.
# For further hacks, here are the assumptions made by the current code:
# - Given the address x of a boost::multi_index_container object, one can find
#   the address of the head node by casting the container into its second
#   subclass, and following the 'member' pointer.
# - Each node is stored in memory as:
#   (Element, index_n-1_fields, ..., index_0_fields)
# - The size of an Element is rounded up to the next multiple of 8.
# - The size of the index fields for various indexes are in
#   _boost_multi_index_index_size (in number of pointers).
# - For ordered & sequenced indexes:
# - The i-th index field pointers (3 for ordered, 2 for sequenced) point to the
#   address of the destination node's i-th index fields pointers (not to the
#   address of the destination node's Element).
# - The head node pointer of the multiindex container points to the head node's
#   Element address.
# - For ordered indexes:
#   - The last bit of parent_ptr is used to store the node color in the tree, so
#     it must be AND-ed to 0 before following the ptr.
#   - Inside the head node, the pointers specify:
#     parent_ptr: root node
#     left_ptr: node with smallest element
#     right_ptr: node with largest element
#   - The elements are stored in a sorted binary tree (probably balanced, but we
#     don't care about that for printing). So, given a node x, all nodes in the
#     left subtree of x appear before x when ordered, and all nodes in the right
#     subtree appear after x.
# - For sequenced indexes:
#   - The index field contains: previous@0 and next@1.
#   - To traverse the container, keep following next pointers until returning
#     back to the head node.
#
# 2. The python framework in gdb is limited. To cast a
# boost::multi_index_container to one of its super classes, I use an awkward
# parse_and_eval() that can be broken by as little as output formatting changes.
#

@_register_printer
class Boost_Multi_Index:
    "Printer for boost::multi_index_container"
    printer_name = 'boost::multi_index_container'
    version = '1.42'

    #
    # To specify which index to use for printing for a specific container
    # (dynamically, inside gdb), add its address here as key, and the desired
    # index as value. E.g.:
    #
    # (gdb) p &s_5
    # $2 = (Int_Set_5 *) 0x7fffffffd770
    # (gdb) python import boost.printers
    # (gdb) python boost.printers.Boost_Multi_Index.idx[0x7fffffffd770] = 1
    # (gdb) p s_5
    #
    idx = {}

    #
    # Not supported indexes (hashes and random-access) are captured and printed
    # by this subprinter. To disable this, set this to False. This can be set in
    # the source code, in .gdbinit where the printers are loaded, or dynamically
    # from inside gdb.
    #
    print_not_supported = True

    @classmethod
    def supports(self_type, v):
        if not _is_boost_multi_index(v):
            return False
        _boost_multi_index_get_indexes(v)
        if v.idx >= len(v.indexes):
            return False
        return (self_type.print_not_supported
                or v.indexes[v.idx] == 'boost::multi_index::ordered_unique'
                or v.indexes[v.idx] == 'boost::multi_index::ordered_non_unique'
                or v.indexes[v.idx] == 'boost::multi_index::sequenced')

    @staticmethod
    def get_val_ptr(node_ptr, index_offset):
        return node_ptr - index_offset

    def __init__(self, v):
        # clear up the type_name:
        # pick template name
        self.type_name = v.type_name[0:v.main_args[0][0]].strip()[:-1]
        # add 2 args only (omit allocator)
        self.type_name += ('<'
                           + v.type_name[v.main_args[0][0]:v.main_args[0][1]].strip()
                           + ', '
                           + v.type_name[v.main_args[1][0]:v.main_args[1][1]].strip()
                           + '>')
        # remove bulk
        self.type_name = ''.join(self.type_name.split('boost::multi_index::detail::'))
        self.type_name = ''.join(self.type_name.split('boost::multi_index::'))
        self.type_name = ''.join(self.type_name.split('boost::detail::'))
        self.type_name = ''.join(self.type_name.split(', mpl_::na'))
        self.type_name = ''.join(self.type_name.split('mpl_::na'))
        self.type_name = ''.join(self.type_name.split('tag<>'))
        self.type_name = '<>'.join(self.type_name.split('< >'))
        self.type_name = 'boost::' + self.type_name
        # add index specifier
        self.type_name += '[idx=' + str(v.idx) + ']'
        #print >> sys.stderr, 'type_name: ' + self.type_name

        # index type
        self.index_type = v.indexes[v.idx]

        # node count
        self.node_count = int(v['node_count'])

        # first, we need the element type
        self.elem_type = v.basic_type.template_argument(0)
        #print >> sys.stderr, 'elem_type: ' + str(self.elem_type)

        # next, we compute the element size and round it up to the pointer size
        ptr_size = gdb.lookup_type('void').pointer().sizeof
        self.elem_size = ((self.elem_type.sizeof - 1) / ptr_size + 1) * ptr_size
        #print >> sys.stderr, 'elem_size: ' + str(self.elem_size)

        # next, we cast the object into its 2nd subtype which should be header_holder
        # and retrieve the head node
        header_holder_subtype = _get_subtype(v.basic_type, 1)
        if header_holder_subtype == None:
            print('error computing 2nd subtype of ' + str(v.basic_type), file=sys.stderr)
            return None
        if not str(header_holder_subtype).strip().startswith('boost::multi_index::detail::header_holder'):
            print('2nd subtype of multi_index_container is not header_holder', file=sys.stderr)
            return None
        head_node = v.cast(header_holder_subtype)['member'].dereference()
        #print >> sys.stderr, 'head_node.type.sizeof: ' + str(head_node.type.sizeof)

        # finally, we compute the offset from the element address
        # to the index field address, as well as the address of the parent_ptr
        # inside the head node
        # to do that, we compute the size of all indexes prior to the current one
        self.index_offset = head_node.type.sizeof
        for i in range(v.idx + 1):
            self.index_offset -= _boost_multi_index_index_size[v.indexes[i]] * ptr_size
        #print >> sys.stderr, 'index_offset: ' +  str(self.index_offset)

        self.head_index_ptr = int(head_node.address) + self.index_offset
        #print >> sys.stderr, 'head_index_ptr: ' + hex(self.head_index_ptr)

    def empty_cont(self):
        return self.node_count == 0

    class empty_iterator:
        def __init__(self):
            pass
        def __iter__(self):
            return self
        def __next__(self):
            raise StopIteration

    class na_iterator:
        def __init__(self, index_type):
            self.saw_msg = False
            self.index_type = index_type
        def __iter__(self):
            return self
        def __next__(self):
            if not self.saw_msg:
                self.saw_msg = True
                return (self.index_type, 'printer not implemented')
            raise StopIteration

    class ordered_iterator:
        @staticmethod
        def get_parent_ptr(node_ptr):
            return int(str(gdb.parse_and_eval('*((void**)' + str(node_ptr) + ')')), 16) & (~1)

        @staticmethod
        def get_left_ptr(node_ptr):
            return int(str(gdb.parse_and_eval('*((void**)' + str(node_ptr) + ' + 1)')), 16)

        @staticmethod
        def get_right_ptr(node_ptr):
            return int(str(gdb.parse_and_eval('*((void**)' + str(node_ptr) + ' + 2)')), 16)

        def __init__(self, elem_type, index_offset, first, last):
            self.elem_type = elem_type
            self.index_offset = index_offset
            self.crt = first
            self.last = last
            self.saw_last = False
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            if self.crt == self.last and self.saw_last:
                raise StopIteration
            crt = self.crt
            #print >> sys.stderr, 'crt: ' + hex(crt)
            if self.crt == self.last:
                self.saw_last = True
            else:
                if self.get_right_ptr(self.crt) != 0:
                    # next is leftmost node in right subtree
                    #print >> sys.stderr, 'next is in right subtree'
                    self.crt = self.get_right_ptr(self.crt)
                    while self.get_left_ptr(self.crt) != 0:
                        self.crt = self.get_left_ptr(self.crt)
                else:
                    # next is first ancestor from which crt is in left subtree
                    #print >> sys.stderr, 'next is an ancestor'
                    while True:
                        old_crt = self.crt
                        self.crt = self.get_parent_ptr(self.crt)
                        if self.get_left_ptr(self.crt) == old_crt:
                            break
                #print >> sys.stderr, 'next: ' + hex(self.crt)
            count = self.count
            self.count = self.count + 1
            val_ptr = Boost_Multi_Index.get_val_ptr(crt, self.index_offset)
            return ('[%s]' % hex(int(val_ptr)),
                    str(gdb.parse_and_eval('*(' + str(self.elem_type) + '*)'
                                           + str(val_ptr))))

    class sequenced_iterator:
        @staticmethod
        def get_prev_ptr(node_ptr):
            return int(str(gdb.parse_and_eval('*((void**)' + str(node_ptr) + ')')), 16)

        @staticmethod
        def get_next_ptr(node_ptr):
            return int(str(gdb.parse_and_eval('*((void**)' + str(node_ptr) + ' + 1)')), 16)

        def __init__(self, elem_type, index_offset, begin, end):
            self.elem_type = elem_type
            self.index_offset = index_offset
            self.crt = begin
            self.end = end
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            if self.crt == self.end:
                raise StopIteration
            crt = self.crt
            self.crt = self.get_next_ptr(self.crt)
            count = self.count
            self.count = self.count + 1
            val_ptr = Boost_Multi_Index.get_val_ptr(crt, self.index_offset)
            return ('[%s]' % hex(int(val_ptr)),
                    str(gdb.parse_and_eval('*(' + str(self.elem_type) + '*)'
                                           + str(val_ptr))))

    def children(self):
        if self.empty_cont():
            return self.empty_iterator()
        if (self.index_type == 'boost::multi_index::ordered_unique'
            or self.index_type == 'boost::multi_index::ordered_non_unique'):
            return self.ordered_iterator(
                self.elem_type,
                self.index_offset,
                self.ordered_iterator.get_left_ptr(self.head_index_ptr),
                self.ordered_iterator.get_right_ptr(self.head_index_ptr))
        elif self.index_type == 'boost::multi_index::sequenced':
            return self.sequenced_iterator(
                self.elem_type,
                self.index_offset,
                self.sequenced_iterator.get_next_ptr(self.head_index_ptr),
                self.head_index_ptr)
        return self.na_iterator(self.index_type)

    def to_string(self):
        if self.empty_cont():
            return 'empty %s' % self.type_name
        return '%s' % self.type_name
